/*
Copyright 2013, KISSY UI Library v1.40dev
MIT Licensed
build time: Jul 3 13:49
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 combobox/combobox-tpl
 combobox/render
 combobox/control
 combobox/cursor
 combobox/multi-value-combobox
 combobox/filter-select
 combobox/local-data-source
 combobox/remote-data-source
 combobox
*/

/*
  Generated by kissy-tpl2mod.
*/
KISSY.add('combobox/combobox-tpl',
'<div id="ks-combobox-invalid-el-{{id}}" class="{{getBaseCssClasses "invalid-el"}}"> <div class="{{getBaseCssClasses "invalid-inner"}}"></div> </div> {{#if hasTrigger}} <div id="ks-combobox-trigger-{{id}}" class="{{getBaseCssClasses "trigger"}}"> <div class="{{getBaseCssClasses "trigger-inner"}}">&#x25BC;</div> </div> {{/if}} <div class="{{getBaseCssClasses "input-wrap"}}"> <input id="ks-combobox-input-{{id}}" aria-haspopup="true" aria-autocomplete="list" aria-haspopup="true" role="autocomplete" aria-expanded="false" {{#if disabled}} disabled {{/if}} autocomplete="off" class="{{getBaseCssClasses "input"}}" value="{{value}}" /> <label id="ks-combobox-placeholder-{{id}}" for="ks-combobox-input-{{id}}" style=\'display:{{#if value}}none{{else}}block{{/if}};\' class="{{getBaseCssClasses "placeholder"}}"> {{placeholder}} </label> </div>');
/**
 * @ignore
 * Render aria properties to input element.
 * @author yiminghe@gmail.com
 */
KISSY.add("combobox/render", function (S, Control, ComboboxTpl) {

    var ComboboxRender = Control.ATTRS.xrender.value.extend({

        beforeCreateDom: function (renderData, childrenElSelectors) {
            S.mix(childrenElSelectors, {
                input: '#ks-combobox-input-{id}',
                trigger: '#ks-combobox-trigger-{id}',
                invalidEl: '#ks-combobox-invalid-el-{id}',
                placeholderEl: '#ks-combobox-placeholder-{id}'
            });
        },

        getKeyEventTarget: function () {
            return this.control.get("input");
        },

        _onSetCollapsed: function (v) {
            this.control.get("input").attr("aria-expanded", !v);
        },

        _onSetDisabled: function (v) {
            ComboboxRender.superclass._onSetDisabled.apply(this, arguments);
            this.control.get("input").attr("disabled", v);
        }

    }, {
        ATTRS: {
            contentTpl: {
                value: ComboboxTpl
            }
        },
        HTML_PARSER: {
            value: function (el) {
                return el.one("." + this.getBaseCssClass('input')).val();
            },
            input: function (el) {
                return el.one("." + this.getBaseCssClass('input'));
            },
            trigger: function (el) {
                return el.one("." + this.getBaseCssClass('trigger'));
            },
            invalidEl: function (el) {
                return el.one("." + this.getBaseCssClass('invalid-el'));
            },
            placeholderEl: function (el) {
                return el.one("." + this.getBaseCssClass('placeholder'));
            }
        }
    });

    return ComboboxRender;
}, {
    requires: ['component/control', './combobox-tpl']
});
/**
 * @ignore
 * Input wrapper for ComboBox component.
 * @author yiminghe@gmail.com
 */
KISSY.add("combobox/control", function (S, Node, Control, ComboBoxRender, Menu, undefined) {
    var ComboBox,
        KeyCode = Node.KeyCode;

    /**
     * KISSY ComboBox.
     * xclass: 'combobox'.
     * @extends KISSY.Component.Control
     * @class KISSY.ComboBox
     */
    ComboBox = Control.extend({

            // user's input text.
            // for restore after press esc key
            // if update input when press down or up key
            _savedValue: null,

            /**
             * normalize returned data
             * @protected
             * @param data
             */
            'normalizeData': function (data) {
                var self = this,
                    contents, v, i, c;
                if (data && data.length) {
                    data = data.slice(0, self.get("maxItemCount"));
                    if (self.get("format")) {
                        contents = self.get("format").call(self,
                            self.getValueForAutocomplete(), data);
                    } else {
                        contents = [];
                    }
                    for (i = 0; i < data.length; i++) {
                        v = data[i];
                        c = contents[i] = S.mix({
                            content: v,
                            textContent: v,
                            value: v
                        }, contents[i]);
                    }
                    return contents;
                }
                return contents;
            },

            bindUI: function () {
                var self = this,
                    input = self.get("input");

                input.on("valuechange", onValueChange, self);

                /**
                 * fired after combobox 's collapsed attribute is changed.
                 * @event afterCollapsedChange
                 * @param e
                 * @param e.newVal current value
                 * @param e.prevVal previous value
                 */

                self.on('click', onMenuItemClick, self);

                self.get('menu').onRendered(function (menu) {
                    onMenuAfterRenderUI(self, menu);
                });
            },

            destructor:function(){
                this.get('menu').destroy();
            },

            /**
             * get value
             * @protected
             */
            getValueForAutocomplete: function () {
                return this.get('value');
            },

            /**
             * set value
             * @protected
             * @method
             * @member KISSY.ComboBox
             */
            setValueFromAutocomplete: function (value, setCfg) {
                this.set('value', value, setCfg);
            },

            // buffer/bridge between check timer and change logic
            '_onSetValue': function (v, e) {
                var self = this,
                    value;
                // only trigger menu when timer cause change
                if (e.causedByTimer) {
                    value = self['getValueForAutocomplete']();
                    // undefined means invalid input value
                    if (value === undefined) {
                        self.set("collapsed", true);
                        return;
                    }
                    self._savedValue = value;
                    // S.log("value change: " + value);
                    self.sendRequest(value);
                } else {
                    // S.log('set input val: ' + v);
                    self.get('input').val(v);
                }
            },

            handleFocusInternal: function () {
                var self = this,
                    placeholderEl;
                if (self.get('invalidEl')) {
                    setInvalid(self, false);
                }
                if (placeholderEl = self.get("placeholderEl")) {
                    placeholderEl.hide();
                }
            },

            handleBlurInternal: function () {
                // S.log('blur');
                var self = this,
                    placeholderEl = self.get("placeholderEl");
                ComboBox.superclass.handleBlurInternal.apply(self, arguments);
                delayHide(self);
                if (self.get('invalidEl')) {
                    self.validate(function (error, val) {
                        if (error) {
                            if (!self.get("focused") && val == self.get('value')) {
                                setInvalid(self, error);
                            }
                        } else {
                            setInvalid(self, false);
                        }
                    });
                }
                if (placeholderEl && !self.get('value')) {
                    placeholderEl.show();
                }
            },

            handleMouseDownInternal: function (e) {
                var self = this,
                    target,
                    trigger;
                ComboBox.superclass.handleMouseDownInternal.apply(self, arguments);
                target = e.target;
                trigger = self.get("trigger");
                if (trigger && (trigger[0] == target || trigger.contains(target))) {
                    if (self.get('collapsed')) {
                        // fetch data
                        self.focus();
                        self.sendRequest('');
                    } else {
                        // switch from open to collapse
                        self.set('collapsed', true);
                    }
                    e.preventDefault();
                }
            },

            handleKeyDownInternal: function (e) {
                var self = this,
                    updateInputOnDownUp,
                    input,
                    keyCode = e.keyCode,
                    highlightedItem,
                    handledByMenu,
                    menu = self.get("menu");

                input = self.get("input");
                updateInputOnDownUp = self.get("updateInputOnDownUp");

                if (menu.get("visible")) {

                    highlightedItem = menu.get("highlightedItem");

                    // https://github.com/kissyteam/kissy/issues/371
                    // combobox: input should be involved in key press sequence
                    if (updateInputOnDownUp && highlightedItem) {
                        var menuChildren = menu.get('children');
                        if (keyCode == KeyCode.DOWN &&
                            highlightedItem == getFirstEnabledItem(menuChildren.concat().reverse())
                            ||
                            keyCode == KeyCode.UP &&
                                highlightedItem == getFirstEnabledItem(menuChildren)
                            ) {
                            self.setValueFromAutocomplete(self._savedValue);
                            highlightedItem.set('highlighted', false);
                            return true;
                        }
                    }

                    handledByMenu = menu.handleKeyDownInternal(e);

                    highlightedItem = menu.get("highlightedItem");

                    // esc
                    if (keyCode == KeyCode.ESC) {
                        self.set("collapsed", true);
                        if (updateInputOnDownUp) {
                            // combobox will change input value
                            // but it does not need to reload data
                            // restore original user's input text
                            self.setValueFromAutocomplete(self._savedValue);
                        }
                        return true;
                    }

                    if (updateInputOnDownUp &&
                        S.inArray(keyCode, [KeyCode.DOWN, KeyCode.UP])) {
                        // update menu's active value to input just for show
                        self.setValueFromAutocomplete(highlightedItem.get("textContent"));
                    }

                    // tab
                    // if menu is open and an menuitem is highlighted, see as click/enter
                    if (keyCode == KeyCode.TAB && highlightedItem) {
                        // click highlightedItem
                        highlightedItem.handleClickInternal();
                        // only prevent focus change in multiple mode
                        if (self.get("multiple")) {
                            return true;
                        }
                    }

                    return handledByMenu;
                } else if (keyCode == KeyCode.DOWN || keyCode == KeyCode.UP) {
                    // re-fetch, consider multiple input
                    var v = self.getValueForAutocomplete();
                    if (v !== undefined) {
                        self.sendRequest(v);
                    }
                }
                return  undefined;
            },

            validate: function (callback) {
                var self = this,
                    validator = self.get('validator'),
                    val = self.getValueForAutocomplete();

                if (validator) {
                    validator(val, function (error) {
                        callback(error, val);
                    });
                } else {
                    callback(false, val);
                }
            },

            /**
             * fetch comboBox list by value and show comboBox list
             * @param {String} value value for fetching comboBox list
             */
            sendRequest: function (value) {
                var self = this,
                    dataSource = self.get("dataSource");
                dataSource.fetchData(value, renderData, self);
            },

            _onSetCollapsed: function (v) {
                var self = this,
                    el = self.$el,
                    menu = self.get('menu');
                if (v) {
                    menu.hide();
                } else {
                    // 保证显示前已经 bind 好 menu 事件
                    clearDismissTimer(self);
                    if (!menu.get("visible")) {
                        if (self.get("matchElWidth")) {
                            menu.render();
                            var menuEl = menu.get('el');
                            var borderWidth =
                                (parseInt(menuEl.css('borderLeftWidth')) || 0) +
                                    (parseInt(menuEl.css('borderRightWidth')) || 0);
                            menu.set("width", el[0].offsetWidth - borderWidth);
                        }
                        menu.show();
                    }
                }
            }
        },
        {
            ATTRS: {

                /**
                 * Input element of current combobox.
                 * @type {KISSY.NodeList}
                 * @property input
                 */
                /**
                 * @ignore
                 */
                input: {
                },

                /**
                 * initial value for input
                 * @cfg {String} inputValue
                 */
                /**
                 * @ignore
                 */
                value: {
                    value: '',
                    sync: 0,
                    view: 1
                },

                /**
                 * trigger arrow element
                 * @ignore
                 */
                trigger: {
                },

                /**
                 * placeholder
                 * @cfg {String} placeholder
                 */
                /**
                 * @ignore
                 */
                placeholder: {
                    view: 1
                },


                /**
                 * label for placeholder in ie
                 * @ignore
                 */
                placeholderEl: {
                },

                /**
                 * custom validation function
                 * @type Function
                 * @property validator
                 */
                /**
                 * @ignore
                 */
                validator: {
                },

                /**
                 * invalid tag el
                 * @ignore
                 */
                invalidEl: {
                },

                allowTextSelection: {
                    value: true
                },

                /**
                 * Whether show combobox trigger.
                 * Defaults to: true.
                 * @cfg {Boolean} hasTrigger
                 */
                /**
                 * @ignore
                 */
                hasTrigger: {
                    value: true,
                    view: 1
                },

                /**
                 * ComboBox dropDown menuList or config
                 * @cfg {KISSY.Menu.PopupMenu|Object} menu
                 */
                /**
                 * ComboBox dropDown menuList or config
                 * @property menu
                 * @type {KISSY.Menu.PopupMenu}
                 */
                /**
                 * @ignore
                 */
                menu: {
                    value: {
                    },
                    getter: function (v) {
                        if (!v.isControl) {
                            v.xclass = v.xclass || 'popupmenu';
                            v = this.createComponent(v);
                            this.setInternal('menu', v);
                        }
                        return v;
                    },
                    setter: function (m) {
                        if (m.isControl) {
                            m.setInternal('parent', this);
                            var align = {
                                node: this.$el,
                                points: ["bl", "tl"],
                                overflow: {
                                    adjustX: 1,
                                    adjustY: 1
                                }
                            };
                            S.mix(m.get('align'), align, false);
                        }
                    }
                },

                /**
                 * Whether combobox menu is hidden.
                 * @type {Boolean}
                 * @property collapsed
                 */
                /**
                 * @ignore
                 */
                collapsed: {
                    view: 1,
                    value: true
                },

                /**
                 * dataSource for comboBox.
                 * @cfg {KISSY.ComboBox.LocalDataSource|KISSY.ComboBox.RemoteDataSource|Object} dataSource
                 */
                /**
                 * @ignore
                 */
                dataSource: {
                    // 和 input 关联起来，input可以有很多，每个数据源可以不一样，但是 menu 共享
                },

                /**
                 * maxItemCount max count of data to be shown
                 * @cfg {Number} maxItemCount
                 */
                /**
                 * @ignore
                 */
                maxItemCount: {
                    value: 99999
                },

                /**
                 * Whether drop down menu is same width with input.
                 * Defaults to: true.
                 * @cfg {Boolean} matchElWidth
                 */
                /**
                 * @ignore
                 */
                matchElWidth: {
                    value: true
                },

                /**
                 * Format function to return array of
                 * html/text/menu item attributes from array of data.
                 * @cfg {Function} format
                 */
                /**
                 * @ignore
                 */
                format: {
                },

                /**
                 * Whether update input's value at keydown or up when combobox menu shows.
                 * Default to: true
                 * @cfg {Boolean} updateInputOnDownUp
                 */
                /**
                 * @ignore
                 */
                updateInputOnDownUp: {
                    value: true
                },

                /**
                 * Whether or not the first row should be highlighted by default.
                 * Defaults to: false
                 * @cfg {Boolean} autoHighlightFirst
                 */
                /**
                 * @ignore
                 */
                autoHighlightFirst: {
                },

                /**
                 * whether highlight item when item content is same with user input.
                 * Defaults to: true
                 * @cfg {Boolean} highlightMatchItem
                 */
                /**
                 * @ignore
                 */
                highlightMatchItem: {
                    value: true
                },

                xrender: {
                    value: ComboBoxRender
                }
            },
            xclass: 'combobox'
        });


    // #----------------------- private start

    function getFirstEnabledItem(children) {
        for (var i = 0; i < children.length; i++) {
            if (!children[i].get('disabled')) {
                return children[i];
            }
        }
        return null;
    }

    function onMenuFocusout() {
        var combobox = this;
        // S.log('focusout');
        delayHide(combobox);
    }

    function onMenuFocusin() {
        var combobox = this;
        // S.log('focusin');
        // different event sequence
        // ie fire focusin blur
        // others fire blur focusin
        setTimeout(function () {
            clearDismissTimer(combobox);
        }, 0);
    }

    function onMenuMouseOver() {
        var combobox = this;
        // trigger el focus
        self.focus();
        // prevent menu from hiding
        clearDismissTimer(combobox);
    }

    function onMenuMouseDown() {
        var combobox = this;
        // consider multi-input
        // input.val(self.get('value'));
        // force change event for cursor keep
        combobox.setValueFromAutocomplete(combobox.getValueForAutocomplete(), {
            force: 1
        });
    }

    function onMenuAfterRenderUI(self, menu) {
        var contentEl;
        var input = self.get('input');
        var el = menu.get('el');
        contentEl = menu.get("contentEl");
        input.attr("aria-owns", el.attr('id'));
        // menu has input!
        el.on("focusout", onMenuFocusout, self);
        el.on("focusin", onMenuFocusin, self);
        contentEl.on("mouseover", onMenuMouseOver, self);
        // cause valuechange
        // if click menuitem while chinese input is open(xu -> '')
        contentEl.on('mousedown', onMenuMouseDown, self);
    }

    function onMenuItemClick(e) {
        var item = e.target,
            self = this,
            textContent;
        if (item.isMenuItem) {
            textContent = item.get('textContent');
            self.setValueFromAutocomplete(textContent);
            self._savedValue = textContent;
            self.set("collapsed", true);
        }
    }

    function setInvalid(self, error) {
        var $el = self.$el,
            cls = self.view.getBaseCssClasses('invalid'),
            invalidEl = self.get("invalidEl");
        if (error) {
            $el.addClass(cls);
            invalidEl.attr("title", error);
            invalidEl.show();
        } else {
            $el.removeClass(cls);
            invalidEl.hide();
        }
    }

    function delayHide(self) {
        if (self._focusoutDismissTimer) {
            return;
        }
        self._focusoutDismissTimer = setTimeout(function () {
                // S.log('hide by delay ' + self._focusoutDismissTimer);
                // ie6 bug
                if (self._focusoutDismissTimer) {
                    self.set("collapsed", true);
                }
            },
            // ie6 needs longer timeout
            50);
        // S.log('delayHide ' + self._focusoutDismissTimer);
    }

    function clearDismissTimer(self) {
        var t;
        if (t = self._focusoutDismissTimer) {
            // S.log('clearDismissTimer ' + t);
            clearTimeout(t);
            self._focusoutDismissTimer = null;
        }
    }

    function onValueChange(e) {
        this.set('value', e.newVal, {
            data: {
                causedByTimer: 1
            }
        });
    }

    function renderData(data) {
        var self = this,
            v,
            children = [],
            val,
            matchVal,
            highlightedItem,
            i,
            menu = self.get("menu");

        data = self['normalizeData'](data);

        menu.removeChildren(true);

        if (highlightedItem = menu.get('highlightedItem')) {
            highlightedItem.set('highlighted', false);
        }

        if (data && data.length) {

            for (i = 0; i < data.length; i++) {
                v = data[i];
                menu.addChild(v);
            }

            children = menu.get('children');

            // make menu item (which textContent is same as input) active
            val = self['getValueForAutocomplete']();

            if (self.get('highlightMatchItem')) {
                for (i = 0; i < children.length; i++) {
                    if (children[i].get("textContent") == val) {
                        children[i].set('highlighted', true);
                        matchVal = true;
                        break;
                    }
                }
            }

            // Whether or not the first row should be highlighted by default.
            if (!matchVal && self.get("autoHighlightFirst")) {
                for (i = 0; i < children.length; i++) {
                    if (!children[i].get("disabled")) {
                        children[i].set('highlighted', true);
                        break;
                    }
                }
            }

            self.set("collapsed", false);

        } else {
            self.set("collapsed", true);
        }
    }

    // #------------------------private end

    return ComboBox;
}, {
    requires: [
        'node',
        'component/control',
        './render',
        'menu'
    ]
});

/**
 * @ignore
 *
 * !TODO
 *  - menubutton combobox 抽象提取 picker (extjs)
 *
 *
 * 2012-05
 * auto-complete menu 对齐当前输入位置
 *  - http://kirblog.idetalk.com/2010/03/calculating-cursor-position-in-textarea.html
 *  - https://github.com/kir/js_cursor_position
 *
 * 2012-04-01 可能 issue :
 *  - 用户键盘上下键高亮一些选项，
 *    input 值为高亮项的 textContent,那么点击 body 失去焦点，
 *    到底要不要设置 selectedItem 为当前高亮项？
 *    additional note:
 *    1. tab 时肯定会把当前高亮项设置为 selectedItem
 *    2. 鼠标时不会把高亮项的 textContent 设到 input 上去
 *    1,2 都没问题，关键是键盘结合鼠标时怎么个处理？或者不考虑算了！
 **/
/**
 * @ignore
 * get cursor position of input
 * @author yiminghe@gmail.com
 */
KISSY.add('combobox/cursor', function (S, Node) {

    var $ = Node.all,
        FAKE_DIV_HTML = "<div style='" +
            "z-index:-9999;" +
            "overflow:hidden;" +
            "position: fixed;" +
            "left:-9999px;" +
            "top:-9999px;" +
            "opacity:0;" +
            // firefox default normal,need to force to use pre-wrap
            "white-space:pre-wrap;" +
            "word-wrap:break-word;" +
            "'></div>",
        FAKE_DIV,
        MARKER = "<span>" +
            // must has content
            // or else <br/><span></span> can not get right coordinates
            "x" +
            "</span>",
        STYLES = [
            'paddingLeft',
            'paddingTop', 'paddingBottom',
            'paddingRight',
            'marginLeft',
            'marginTop',
            'marginBottom',
            'marginRight',
            'borderLeftStyle',
            'borderTopStyle',
            'borderBottomStyle',
            'borderRightStyle',
            'borderLeftWidth',
            'borderTopWidth',
            'borderBottomWidth',
            'borderRightWidth',
            'line-height',
            'outline',
            'height',
            'fontFamily',
            'fontSize',
            'fontWeight',
            'fontVariant',
            'fontStyle'
        ],
        supportInputScrollLeft,
        findSupportInputScrollLeft;

    function getFakeDiv(elem) {
        var fake = FAKE_DIV;
        if (!fake) {
            fake = $(FAKE_DIV_HTML);
        }
        if (String(elem.type) == 'textarea') {
            fake.css("width", elem.css("width"));
        } else {
            // input does not wrap at all
            fake.css("width", 9999);
        }
        S.each(STYLES, function (s) {
            fake.css(s, elem.css(s));
        });
        if (!FAKE_DIV) {
            fake.insertBefore(elem[0].ownerDocument.body.firstChild);
        }
        FAKE_DIV = fake;
        return fake;
    }

    findSupportInputScrollLeft = function () {
        var doc = document,
            input = $("<input>");
        input.css({
            width: 1,
            position: "absolute",
            left: -9999,
            top: -9999
        });
        input.val("123456789");
        input.appendTo(doc.body);
        input[0].focus();
        supportInputScrollLeft = !!(input[0].scrollLeft > 0);
        input.remove();
        findSupportInputScrollLeft = S.noop;
    };

    // firefox not support, chrome support
    supportInputScrollLeft = false;

    return function (elem) {
        var $elem = $(elem);
        elem = $elem[0];
        var doc = elem.ownerDocument,
            $doc = $(doc),
            elemOffset,
            range,
            fake,
            selectionStart,
            offset,
            marker,
            elemScrollTop = elem.scrollTop,
            elemScrollLeft = elem.scrollLeft;
        if (doc.selection) {
            range = doc.selection.createRange();
            return {
                // http://msdn.microsoft.com/en-us/library/ie/ms533540(v=vs.85).aspx
                // or simple range.offsetLeft for textarea
                left: range.boundingLeft + elemScrollLeft +
                    $doc.scrollLeft(),
                top: range.boundingTop + elemScrollTop +
                    range.boundingHeight + $doc.scrollTop()
            };
        }

        elemOffset = $elem.offset();

        // input does not has scrollLeft
        // so just get the position of the beginning of input
        if (!supportInputScrollLeft && elem.type != 'textarea') {
            elemOffset.top += elem.offsetHeight;
            return elemOffset;
        }

        fake = getFakeDiv($elem);

        selectionStart = elem.selectionStart;

        fake.html(S.escapeHtml(elem.value.substring(0, selectionStart - 1)) +
            // marker
            MARKER);

        // can not set fake to scrollTop，marker is always at bottom of marker
        // when cursor at the middle of textarea , error occurs
        // fake.scrollTop = elemScrollTop;
        // fake.scrollLeft = elemScrollLeft;
        offset = elemOffset;

        // offset.left += 500;
        fake.offset(offset);
        marker = fake.last();
        offset = marker.offset();
        offset.top += marker.height();
        // at the start of textarea , just fetch marker's left
        if (selectionStart > 0) {
            offset.left += marker.width();
        }

        // so minus scrollTop/Left
        offset.top -= elemScrollTop;
        offset.left -= elemScrollLeft;

        // offset.left -= 500;
        return offset;
    };

}, {
    requires: ['node']
});
/**
 * @ignore
 * Input wrapper for ComboBox component.
 * @author yiminghe@gmail.com
 */
KISSY.add("combobox/multi-value-combobox", function (S, getCursor, ComboBox) {

    var SUFFIX = 'suffix',
        rWhitespace = /\s|\xa0/;

    function strContainsChar(str, c) {
        return c && str.indexOf(c) != -1;
    }

    function beforeVisibleChange(e) {
        if (e.newVal && e.target == this.get('menu')) {
            this.alignWithCursor();
        }
    }

    /**
     * KISSY MultiValueComboBox.
     * @extends KISSY.ComboBox
     * @class KISSY.ComboBox.MultiValueComboBox
     */
    return ComboBox.extend({

            syncUI: function () {
                var self = this,
                    menu;
                if (self.get('alignWithCursor')) {
                    menu = self.get('menu');
                    menu.setInternal('align',null);
                    menu.on('beforeVisibleChange', beforeVisibleChange, this);
                }
            },

            getValueForAutocomplete: function () {

                var self = this,
                    inputDesc = getInputDesc(self),
                    tokens = inputDesc.tokens,
                    tokenIndex = inputDesc.tokenIndex,
                    separator = self.get("separator"),
                    separatorType = self.get("separatorType"),
                    token = tokens[tokenIndex],
                    l = token.length - 1;

                if (separatorType != SUFFIX) {
                    if (strContainsChar(separator, token.charAt(0))) {
                        token = token.slice(1);
                    } else {
                        // 无效输入，前缀模式无前缀
                        return undefined;
                    }
                }

                else if (separatorType == SUFFIX && strContainsChar(separator, token.charAt(l))) {
                    token = token.slice(0, l);
                }

                return token;

            },

            setValueFromAutocomplete: function (value, setCfg) {
                var self = this,
                    input = self.get("input"),
                    inputDesc = getInputDesc(self),
                    tokens = inputDesc.tokens,
                    tokenIndex = Math.max(0, inputDesc.tokenIndex),
                    separator = self.get("separator"),
                    cursorPosition,
                    l,
                    separatorType = self.get("separatorType"),
                    nextToken = tokens[tokenIndex + 1] || "",
                    token = tokens[tokenIndex];

                if (separatorType != SUFFIX) {
                    tokens[tokenIndex] = token.charAt(0) + value;
                    if (nextToken && rWhitespace.test(nextToken.charAt(0))) {
                    } else if (value) {
                        // 自动加空白间隔
                        tokens[tokenIndex] += ' ';
                    }
                } else {
                    tokens[tokenIndex] = value;
                    l = token.length - 1;
                    // 尽量补上后缀
                    if (strContainsChar(separator, token.charAt(l))) {
                        tokens[tokenIndex] += token.charAt(l);
                    } else if (separator.length == 1) {
                        // 自动加后缀
                        tokens[tokenIndex] += separator;
                    }
                }

                cursorPosition = tokens.slice(0, tokenIndex + 1).join("").length;

                self.set('value', tokens.join(""), setCfg);

                input.prop("selectionStart", cursorPosition);
                input.prop("selectionEnd", cursorPosition);
            },

            'alignWithCursor': function () {
                var self = this;
                // does not support align with separator
                // will cause ime error
                var menu = self.get("menu"),
                    cursorOffset,
                    input = self.get("input");
                cursorOffset = getCursor(input);
                menu.move(cursorOffset.left, cursorOffset.top);
            }
        },
        {
            ATTRS: {

                /**
                 * Separator chars used to separator multiple inputs.
                 * Defaults to: ;,
                 * @cfg {String} separator
                 */
                /**
                 * @ignore
                 */
                separator: {
                    value: ",;"
                },

                /**
                 * Separator type.
                 * After value( 'suffix' ) or before value( 'prefix' ).
                 * Defaults to: 'suffix'
                 * @cfg {String} separatorType
                 */
                /**
                 * @ignore
                 */
                separatorType: {
                    value: SUFFIX
                },

                /**
                 * If separator wrapped by literal chars,separator become normal chars.
                 * Defaults to: "
                 * @cfg {String} literal
                 */
                /**
                 * @ignore
                 */
                literal: {
                    value: "\""
                },

                /**
                 * Whether align menu with individual token after separated by separator.
                 * Defaults to: false
                 * @cfg {Boolean} alignWithCursor
                 */
                /**
                 * @ignore
                 */
                alignWithCursor: {
                }
            },
            xclass: 'multi-value-combobox'
        });

    // #----------------------- private start

    function getInputDesc(self) {
        var input = self.get("input"),
            inputVal = self.get('value'),
            tokens = [],
            cache = [],
            literal = self.get("literal"),
            separator = self.get("separator"),
            separatorType = self.get("separatorType"),
            inLiteral = false,
        // 每个空格算作独立 token
            allowWhitespaceAsStandaloneToken = separatorType != SUFFIX,
            cursorPosition = input.prop('selectionStart'),
            i,
            c,
            tokenIndex = -1;

        for (i = 0; i < inputVal.length; i++) {
            c = inputVal.charAt(i);
            if (literal) {
                if (c == literal) {
                    inLiteral = !inLiteral;
                }
            }
            if (inLiteral) {
                cache.push(c);
                continue;
            }
            if (i == cursorPosition) {
                // current token index
                tokenIndex = tokens.length;
            }

            // whitespace is not part of token value
            // then separate
            if (allowWhitespaceAsStandaloneToken && rWhitespace.test(c)) {
                if (cache.length) {
                    tokens.push(cache.join(""));
                }
                cache = [];
                cache.push(c);
            } else if (strContainsChar(separator, c)) {
                if (separatorType == SUFFIX) {
                    cache.push(c);
                    if (cache.length) {
                        tokens.push(cache.join(""));
                    }
                    cache = [];
                } else {
                    if (cache.length) {
                        tokens.push(cache.join(""));
                    }
                    cache = [];
                    cache.push(c);
                }
            } else {
                cache.push(c);
            }
        }

        if (cache.length) {
            tokens.push(cache.join(""));
        }

        // 至少有一个
        if (!tokens.length) {
            tokens.push('');
        }

        if (tokenIndex == -1) {
            // 后缀末尾
            // ,^
            if (separatorType == SUFFIX && strContainsChar(separator, c)) {
                tokens.push('');
            }
            tokenIndex = tokens.length - 1;
        }
        return {
            tokens: tokens,
            cursorPosition: cursorPosition,
            tokenIndex: tokenIndex
        };
    }

    // #------------------------private end
}, {
    requires: [
        './cursor',
        './control'
    ]
});

/**
 * @ignore
 *
 * !TODO
 *  - menubutton combobox 抽象提取 picker (extjs)
 *
 *
 * 2012-05
 * auto-complete menu 对齐当前输入位置
 *  - http://kirblog.idetalk.com/2010/03/calculating-cursor-position-in-textarea.html
 *  - https://github.com/kir/js_cursor_position
 *
 * 2012-04-01 可能 issue :
 *  - 用户键盘上下键高亮一些选项，
 *    input 值为高亮项的 textContent,那么点击 body 失去焦点，
 *    到底要不要设置 selectedItem 为当前高亮项？
 *    additional note:
 *    1. tab 时肯定会把当前高亮项设置为 selectedItem
 *    2. 鼠标时不会把高亮项的 textContent 设到 input 上去
 *    1,2 都没问题，关键是键盘结合鼠标时怎么个处理？或者不考虑算了！
 **/
/**
 * @ignore
 * filter select from combobox
 * @author yiminghe@gmail.com
 */
KISSY.add("combobox/filter-select", function (S, Combobox) {

    function valInAutoCompleteList(inputVal, _saveData) {
        var valid = false;
        if (_saveData) {
            for (var i = 0; i < _saveData.length; i++) {
                if (_saveData[i].textContent == inputVal) {
                    return _saveData[i];
                }
            }
        }
        return valid;
    }

    /**
     * validate combobox input by dataSource
     * @class KISSY.ComboBox.FilterSelect
     * @extends KISSY.ComboBox
     */
    var FilterSelect = Combobox.extend({
        validate: function (callback) {
            var self = this;
            FilterSelect.superclass.validate.call(self, function (error, val) {
                if (!error) {
                    self.get("dataSource").fetchData(val, function (data) {
                        var d = valInAutoCompleteList(val, self.normalizeData(data));
                        callback(d ? "" : self.get("invalidMessage"), val, d);
                    });
                } else {
                    callback(error, val);
                }
            });
        }
    }, {
        ATTRS: {
            /**
             * when does not match show invalidMessage
             * @cfg {String} invalidMessage
             */
            /**
             * @ignore
             */
            invalidMessage: {
                value: 'invalid input'
            }
        }
    });

    return FilterSelect;

}, {
    requires: ['./control']
});
/**
 * @ignore
 * Local dataSource for ComboBox
 * @author yiminghe@gmail.com
 */
KISSY.add("combobox/local-data-source", function (S) {

    /**
     * Local dataSource for comboBox.
     * @extends KISSY.Base
     * @class KISSY.ComboBox.LocalDataSource
     */
    function LocalDataSource() {
        LocalDataSource.superclass.constructor.apply(this, arguments);
    }

    function parser(inputVal, data) {
        var ret = [],
            count = 0;
        if (!inputVal) {
            return data;
        }
        S.each(data, function (d) {
            if (d.indexOf(inputVal) != -1) {
                ret.push(d);
            }
            count++;
        });

        return ret;
    }

    LocalDataSource.ATTRS = {
        /**
         * array of static data for comboBox
         * @cfg {Object[]} data
         */
        /**
         * @ignore
         */
        data:{
            value:[]
        },
        /**
         * parse data function.
         * Defaults to: index of match.
         * @cfg {Function} parse
         */
        parse:{
            value:parser
        }
    };

    S.extend(LocalDataSource, S.Base,{
        /**
         * Data source interface. How to get data for comboBox.
         * @param {String} inputVal current active input's value
         * @param {Function} callback callback to notify comboBox when data is ready
         * @param {Object} context callback 's execution context
         */
        fetchData:function (inputVal, callback, context) {
            var parse = this.get("parse"),
                data = this.get("data");
            data = parse(inputVal, data);
            callback.call(context, data);
        }
    });

    return LocalDataSource;
});
/**
 * @ignore
 * Remote datasource for ComboBox
 * @author yiminghe@gmail.com
 */
KISSY.add("combobox/remote-data-source", function (S, IO) {

    /**
     * dataSource which wrap {@link KISSY.IO} utility.
     * @class KISSY.ComboBox.RemoteDataSource
     * @extends KISSY.Base
     */
    function RemoteDataSource() {
        var self = this;
        RemoteDataSource.superclass.constructor.apply(self, arguments);
        self.io = null;
        self.caches = {};
    }

    RemoteDataSource.ATTRS = {
        /**
         * Used as parameter name to send combobox input's value to server.
         * Defaults to: 'q'
         * @cfg  {String} paramName
         */
        /**
         * @ignore
         */
        paramName: {
            value: 'q'
        },
        /**
         * whether send empty to server when input val is empty.
         * Defaults to: false
         * @cfg {Boolean} allowEmpty
         */
        /**
         * @ignore
         */
        allowEmpty: {},
        /**
         * Whether server response data is cached.
         * Defaults to: false
         * @cfg {Boolean} cache
         */
        /**
         * @ignore
         */
        cache: {},
        /**
         * Serve as a parse function to parse server
         * response to return a valid array of data for comboBox.
         * @cfg {Function} parse
         */
        /**
         * @ignore
         */
        parse: {},
        /**
         * IO configuration.same as {@link KISSY.IO}
         * @cfg {Object} xhrCfg
         */
        /**
         * @ignore
         */
        xhrCfg: {
            value: {}
        }
    };

    S.extend(RemoteDataSource, S.Base, {
        /**
         * Data source interface. How to get data for comboBox
         * @param {String} inputVal current active input's value
         * @param {Function} callback callback to notify comboBox when data is ready
         * @param {Object} context callback 's execution context
         */
        fetchData: function (inputVal, callback, context) {
            var self = this,
                v,
                paramName = self.get("paramName"),
                parse = self.get("parse"),
                cache = self.get("cache"),
                allowEmpty = self.get("allowEmpty");
            if (self.io) {
                // abort previous request
                self.io.abort();
                self.io = null;
            }
            if (!inputVal && allowEmpty !== true) {
                return callback.call(context, []);
            }
            if (cache) {
                if (v = self.caches[inputVal]) {
                    return callback.call(context, v);
                }
            }
            var xhrCfg = self.get("xhrCfg");
            xhrCfg.data = xhrCfg.data || {};
            xhrCfg.data[paramName] = inputVal;
            xhrCfg.success = function (data) {
                if (parse) {
                    data = parse(inputVal, data);
                }
                self.setInternal("data", data);
                if (cache) {
                    self.caches[inputVal] = data;
                }
                callback.call(context, data);
            };
            self.io = IO(xhrCfg);
        }
    });
    return RemoteDataSource;
}, {
    requires: ['io']
});
/**
 * @ignore
 * Export ComboBox.
 * @author yiminghe@gmail.com
 */
KISSY.add("combobox", function (S, ComboBox, MultiValueComboBox, FilterSelect, LocalDataSource, RemoteDataSource) {
    ComboBox.LocalDataSource = LocalDataSource;
    ComboBox.RemoteDataSource = RemoteDataSource;
    ComboBox.FilterSelect = FilterSelect;
    ComboBox.MultiValueComboBox = MultiValueComboBox;
    return ComboBox;
}, {
    requires: [
        'combobox/control',
        'combobox/multi-value-combobox',
        'combobox/filter-select',
        'combobox/local-data-source',
        'combobox/remote-data-source'
    ]
});

